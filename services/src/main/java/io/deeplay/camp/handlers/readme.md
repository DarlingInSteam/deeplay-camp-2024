# Команды и обработчики

## 1) StartCommandHandler

### Описание
`StartCommandHandler` обрабатывает команду `start`, которая инициирует или присоединяется к игровой сессии для пользователя.

### Синтаксис запроса

### Пример запроса
```shell
start
```

### Поведение
- Если пользователь авторизован (`isLogin() == true`), метод:
    - Ищет или создает игровую сессию для пользователя.
    - Устанавливает текущую сессию в `mainHandler`.
    - Ожидает начала игры, проверяя статус игры каждую секунду.
    - Создает логические объекты `BoardLogic` и `GameLogic` для текущей сессии.
    - Логирует сообщение о том, что противник найден и игра начинается.
    - Получает информацию о противнике через `SessionManager`.
    - Отправляет сообщение клиенту в формате:
      ```
      session::<ID противника> <Фото противника> <Рейтинг противника> <Количество матчей противника> <Имя пользователя противника> <Эло противника>
      ```
    - Определяет, является ли пользователь первым или вторым игроком, и отображает доску с помощью `GameLogic`.
- Если пользователь не авторизован, метод отправляет клиенту сообщение с просьбой авторизоваться или зарегистрироваться.

### Параметры
- **message**: Строка запроса, содержащая команду. Ожидается, что первый элемент после разделения по пробелам (`split(" ")`) будет командой `start`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение
- Метод не возвращает значение, но отправляет сообщения клиенту через `sendMessageToClient`.

### Пример использования
1. **Авторизованный пользователь**:
    - Запрос: `start`
    - Ответ: `session::<ID противника> <Фото противника> <Рейтинг противника> <Количество матчей противника> <Имя пользователя противника> <Эло противника>`

2. **Неавторизованный пользователь**:
    - Запрос: `start`
    - Ответ: `Please login or register.`

## 2) SessionStartCommandHandler

### Описание
SessionStartCommandHandler обрабатывает команду session-start, которая инициализирует сессию для пользователя после проверки JWT токена.

### Синтаксис запроса

### Пример запроса
```shell
session-start <JWT токен>
```

### Поведение
- Метод разбивает сообщение на части с использованием разделителя MainHandler.splitRegex.
- Извлекает JWT токен из сообщения.
- Извлекает имя пользователя из JWT токена с помощью JwtService.
- Получает пользователя из базы данных с помощью UserService.
- Если JWT токен валиден и пользователь найден:
    - Устанавливает пользователя в mainHandler.
    - Отправляет клиенту сообщение о успешном старте сессии.
    - Отправляет клиенту информацию о пользователе в формате:

      ```plaintext
      session-start::<Имя пользователя>::<Фото пользователя>::<Количество матчей>::<Рейтинг пользователя>
      ```

    - Устанавливает статус логина в mainHandler как true.
- Если пользователь не найден, отправляет сообщение клиенту о том, что пользователь не найден.
- Если JWT токен недействителен или истек, отправляет сообщение клиенту о необходимости повторного входа.

### Параметры
- **message**: Строка запроса, содержащая команду и JWT токен. Ожидается, что второй элемент после разделения по MainHandler.splitRegex будет JWT токеном.
- **mainHandler**: Объект MainHandler, обрабатывающий соединение с клиентом.

### Возвращаемое значение
- Метод не возвращает значение, но отправляет сообщения клиенту через sendMessageToClient.

### Пример использования
1. **Валидный JWT токен и найденный пользователь**:
    - Запрос:
      ```shell
      session-start <JWT токен>
      ```
    - Ответ:
      ```plaintext
      Session started successfully. Welcome back, <Имя пользователя>
      session-start::<Имя пользователя>::<Фото пользователя>::<Количество матчей>::<Рейтинг пользователя>
      ```

2. **Пользователь не найден**:
    - Запрос:
      ```shell
      session-start <JWT токен>
      ```
    - Ответ:
      ```plaintext
      User not found.
      ```

3. **Невалидный или истекший JWT токен**:
    - Запрос:
      ```shell
      session-start <JWT токен>
      ```
    - Ответ:
      ```plaintext
      Invalid or expired JWT token. Please login again.
      ```

## 3) SendSessionChatCommandHandler

### Описание
SendSessionChatCommandHandler обрабатывает команду send-message-session-chat, которая отправляет сообщение в чат текущей игровой сессии.

### Синтаксис запроса

### Пример запроса
```shell
send-message-session-chat <Сообщение>
```

### Поведение
- Метод разбивает сообщение на две части с использованием разделителя MainHandler.splitRegex.
- Отправляет сообщение в текущую сессию через SessionManager.
- Получает текущий чат сессии из mainHandler.
- Формирует строку с сообщениями чата в формате:

```plaintext
::Имя пользователя Сообщение
```

- Создает итоговое сообщение в формате:

```plaintext
send-message-session-chat::<Имя пользователя 1> Сообщение 1::Имя пользователя 2> Сообщение 2::...
```

- Отправляет итоговое сообщение всем пользователям в сессии через SessionManager.

### Параметры
- **message**: Строка запроса, содержащая команду и сообщение чата. Ожидается, что второй элемент после разделения по MainHandler.splitRegex будет сообщением.
- **mainHandler**: Объект MainHandler, обрабатывающий соединение с клиентом.

### Возвращаемое значение
- Метод не возвращает значение, но отправляет сообщения клиенту через sendMessageToClient.

### Пример использования
1. **Отправка сообщения в сессию**:
- Запрос:
 ```shell
 send-message-session-chat Привет всем!
 ```
- Ответ:
 ```plaintext
 send-message-session-chat::Имя пользователя 1 Привет всем!::Имя пользователя 2 Здравствуйте!
 ```

2. **Получение всех сообщений чата сессии**:
- Запрос:
 ```shell
 send-message-session-chat Как дела?
 ```
- Ответ:
 ```plaintext
 send-message-session-chat::Имя пользователя 1 Привет всем!::Имя пользователя 2 Здравствуйте!::Имя пользователя 1 Как дела?
 ```

## 4) SendMessageCommandHandler

### Описание
SendMessageCommandHandler обрабатывает команду send-message, которая отправляет сообщение в общий чат и получает все сообщения чата, чтобы передать их всем пользователям в сессии.

### Синтаксис запроса

### Пример запроса
```shell
send-message <Сообщение>
```

### Поведение
- Метод разбивает сообщение на две части с использованием разделителя MainHandler.splitRegex.
- Извлекает сообщение чата из частей сообщения.
- Добавляет сообщение в чат через ChatService.
- Отправляет клиенту подтверждение об успешной отправке сообщения.
- Получает все сообщения из общего чата через ChatService.
- Формирует строку с сообщениями чата в формате:

```plaintext
::<Временная метка> <Имя пользователя> <Сообщение>
```

- Создает итоговое сообщение в формате:

```plaintext
messages::<Временная метка 1> <Имя пользователя 1> <Сообщение 1>::<Временная метка 2> <Имя пользователя 2> <Сообщение 2>::...
```

- Отправляет итоговое сообщение всем пользователям в сессии через SessionManager.

### Параметры
- **message**: Строка запроса, содержащая команду и сообщение чата. Ожидается, что второй элемент после разделения по MainHandler.splitRegex будет сообщением.
- **mainHandler**: Объект MainHandler, обрабатывающий соединение с клиентом.

### Возвращаемое значение
- Метод не возвращает значение, но отправляет сообщения клиенту через sendMessageToClient.

### Пример использования
1. **Отправка сообщения в общий чат**:
- Запрос:
 ```shell
 send-message Привет всем!
 ```
- Ответ:
 ```plaintext
 Message sent successfully.
 ```

2. **Получение всех сообщений общего чата**:
- Запрос:
 ```shell
 send-message Как дела?
 ```
- Ответ:
 ```plaintext
 messages::<2023-10-01 10:00:00> user1 Привет всем!::<2023-10-01 10:05:00> user2 Здравствуйте!::<2023-10-01 10:10:00> user1 Как дела?
 ```

## 5) RegisterCommandHandler

### Описание
`RegisterCommandHandler` обрабатывает команду регистрации нового пользователя. Он принимает данные пользователя, создает запись в базе данных, генерирует токены обновления и отправляет их обратно клиенту.

### Синтаксис запроса

```plaintext
register <username> <password> <userPhoto>
```

### Пример запроса

```plaintext
register john_doe password123 /path/to/photo.jpg
```

### Поведение

1. Метод разбивает сообщение на части с использованием разделителя `MainHandler.splitRegex`.
2. Извлекает `username`, `password` и `userPhoto` из частей сообщения.
3. Создает объект `User` с данными пользователя и хэширует пароль.
4. Добавляет пользователя в базу данных через `UserService` и получает `userId`.
5. Устанавливает пользователя в `mainHandler`.
6. Отправляет клиенту сообщение об успешной регистрации.
7. Устанавливает флаг входа пользователя в `mainHandler`.
8. Генерирует токены обновления и отправляет их клиенту.

### Параметры

- **message**: Строка запроса, содержащая команду и данные пользователя. Ожидается, что после разделения по `MainHandler.splitRegex` будут доступны `username`, `password` и `userPhoto`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения клиенту через `sendMessageToClient`.

### Пример использования

1. **Регистрация нового пользователя**:
    - Запрос:
      ```plaintext
      register john_doe password123 /path/to/photo.jpg
      ```
    - Ответ:
      ```plaintext
      Registration successful. Welcome, john_doe
      register::<refresh_token>::<update_token>
      ```

## 6) PauseCommandHandler

### Описание
`PauseCommandHandler` обрабатывает команду паузы в игре. Если игра находится в состоянии "в процессе", она отправляет сообщение об остановке игры как клиенту, так и оппоненту. Если игра не в процессе, клиенту отправляется сообщение об ошибке.

### Поведение

1. Проверяет, находится ли состояние игры в `GameStatus.IN_PROGRESS`.
2. Если игра идет, отправляет сообщение "pause" оппоненту и клиенту.
3. Если игра не идет, отправляет клиенту сообщение о невозможности приостановки игры.

### Параметры

- **message**: Строка запроса, содержащая команду. В данном случае, команда ожидается в формате `pause`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения клиенту и оппоненту через `sendMessageToClient` и `sendMessageToOpponent`.

### Пример использования

1. **Пауза игры**:
- Запрос:
 ```plaintext
 pause
 ```
- Ответ, если игра в процессе:
 ```plaintext
 pause
 ```
- Ответ, если игра не в процессе:
 ```plaintext
 Cannot pause game. Game is not in progress.
 ```

## 7) MoveCommandHandler

### Описание
`MoveCommandHandler` обрабатывает команду хода в игре. Он проверяет, является ли пользователь игроком 1 или игроком 2, затем пытается сделать ход. Если ход успешен, он обновляет состояние игры и отправляет обновленный статус доски обоим игрокам. Если ход не успешен, он отправляет сообщение об ошибке клиенту.

### Поведение

1. Определяет, какой игрок делает ход (игрок 1 или игрок 2).
2. Проверяет, авторизован ли пользователь и начата ли сессия игры.
3. Пытается сделать ход, используя переданную команду.
4. Если ход успешен:
    - Логирует успешный ход.
    - Создает объект `BoardDTO` для представления текущего состояния доски.
    - Отправляет обновленное состояние доски клиенту и оппоненту.
    - Проверяет, есть ли победитель, и обновляет состояние игры.
    - Меняет текущего игрока.
5. Если ход не успешен:
    - Логирует неудачный ход.
    - Отправляет сообщение об ошибке клиенту.
6. Если сессия игры не начата, отправляет сообщение клиенту с просьбой начать игру.

### Параметры

- **message**: Строка запроса, содержащая команду. В данном случае, команда ожидается в формате `move x y`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения клиенту и оппоненту через `sendMessageToClient` и `sendMessageToOpponent`.
- Клиенту отправляется сообщение о том, что ход успешен и новое состояние доски.

## 8) LoginCommandHandler

### Описание
`LoginCommandHandler` обрабатывает команду входа в систему. Он проверяет, существует ли пользователь с заданным именем, и сверяет переданный пароль с сохраненным. Если аутентификация успешна, он устанавливает пользователя как текущего в `MainHandler`, генерирует токены обновления и отправляет соответствующие сообщения клиенту.

### Поведение

1. Получает имя пользователя и пароль из сообщения.
2. Ищет пользователя по имени пользователя.
3. Если пользователь существует:
    - Проверяет, совпадает ли переданный пароль с сохраненным паролем пользователя.
    - Если пароли совпадают:
        - Устанавливает пользователя как текущего в `MainHandler`.
        - Генерирует токены обновления.
        - Устанавливает флаг входа в систему в `MainHandler`.
        - Отправляет клиенту сообщение о успешном входе и сгенерированные токены.
    - Если пароли не совпадают:
        - Отправляет клиенту сообщение о неверном пароле.
4. Если пользователь не найден:
    - Отправляет клиенту сообщение о том, что пользователь не найден.

### Параметры

- **message**: Строка запроса, содержащая команду. В данном случае, ожидается, что команда имеет формат `login username password`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения клиенту через `sendMessageToClient`.
- Возвращает токены.

## 9) GetValidMovesCommandHandler

### Описание
`GetValidMovesCommandHandler` обрабатывает команду получения допустимых ходов для текущего пользователя. Он проверяет, какой игрок (1 или 2) запрашивает допустимые ходы, и запрашивает эти ходы у логики игры (`BoardLogic`), после чего отправляет их клиенту.

### Поведение

1. Получает объект логики игры (`BoardLogic`) из `MainHandler`.
2. Получает идентификатор текущего пользователя.
3. Определяет, является ли текущий пользователь первым или вторым игроком в сессии.
4. Запрашивает допустимые ходы для текущего игрока у логики игры.
5. Отправляет клиенту сообщение с допустимыми ходами.

### Параметры

- **message**: Строка запроса, содержащая команду. В данном случае, команда должна быть `get-valid-moves`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения клиенту через `sendMessageToClient`.
- Возвращает доступные этому игроку ходы.

Давайте разберем, что делает класс `GetSessionChatCommandHandler` и какой формат сообщения он отправляет клиенту.

### Описание
`GetSessionChatCommandHandler` обрабатывает команду получения чата сессии. Он собирает все сообщения из чата текущей сессии и отправляет их всем пользователям, участвующим в данной сессии.

## 9) GetSessionChatCommandHandler

### Поведение

1. Получает объект чата сессии (`sessionChat`) из текущей сессии, используя `mainHandler`.
2. Создает `StringBuilder`, чтобы собрать все сообщения из чата сессии.
3. Проходит по каждому сообщению в чате сессии и добавляет его в `StringBuilder` в формате `::username message`.
4. Формирует итоговое сообщение, добавляя префикс `get-messages-session-chat`.
5. Использует `SessionManager`, чтобы отправить сформированное сообщение всем пользователям в текущей сессии.

### Параметры

- **message**: Строка запроса, содержащая команду. В данном случае, команда должна быть `get-session-chat`.
- **mainHandler**: Объект `MainHandler`, обрабатывающий соединение с клиентом.

### Возвращаемое значение

- Метод не возвращает значение, но отправляет сообщения всем пользователям в сессии через `sendMessageToAllInSession`.

### Пример

Предположим, что в чате сессии есть следующие сообщения:

1. Пользователь `Alice` отправил сообщение `Hello everyone!`
2. Пользователь `Bob` отправил сообщение `Hi Alice!`

В этом случае, `StringBuilder` будет содержать следующую строку:

```
::Alice Hello everyone!::Bob Hi Alice!
```

Итоговое сообщение, отправляемое всем пользователям в сессии, будет:

```
get-messages-session-chat::Alice Hello everyone!::Bob Hi Alice!
```

## 10) GetMessagesCommandHandler

Класс `GetMessagesCommandHandler` отвечает за обработку команды получения всех сообщений из общего чата и отправку их клиенту.

### Описание

1. **Создание Сервиса:** Инициализируется объект `ChatService`, который, вероятно, отвечает за взаимодействие с хранилищем сообщений.
2. **Формирование Ответа:** Инициализируется `StringBuilder` с начальной строкой `"messages:"`, которая будет использоваться для построения ответа.
3. **Обработка Команды:** Метод `handle` выполняет следующие шаги:
    - Получает все сообщения из чата, используя метод `getAllMessages` объекта `chatService`.
    - Проходит по каждому сообщению и добавляет его в `response` в формате:
      ```
      timestamp::username::message
      ```
    - Отправляет сформированное сообщение клиенту через метод `sendMessageToClient` объекта `mainHandler`.

### Пример

Предположим, что в чате есть следующие сообщения:

1. Время: `2023-10-01 12:00:00`, Пользователь: `Alice`, Сообщение: `Hello everyone!`
2. Время: `2023-10-01 12:05:00`, Пользователь: `Bob`, Сообщение: `Hi Alice!`

В этом случае, `StringBuilder` будет содержать следующую строку:

```
messages:
2023-10-01 12:00:00::Alice::Hello everyone!
2023-10-01 12:05:00::Bob::Hi Alice!
```

Итоговое сообщение, отправляемое клиенту, будет:

```
messages:
2023-10-01 12:00:00::Alice::Hello everyone!
2023-10-01 12:05:00::Bob::Hi Alice!
```